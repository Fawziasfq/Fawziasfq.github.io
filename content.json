[{"title":"图片画廊案例详解","date":"2017-03-15T13:31:20.000Z","path":"2017/03/15/图片画廊案例详解/","text":"实现方式：CSS3+JS实现海报画廊：CSS来制作效果，JS输出HTML和控制切换 区域模块分解按照空间区域，对复杂的案例效果，分解为几个角简单的模块部分。 当前展现的海报区 水平垂直居中 允许&lt;控制条按钮&gt;控制展现&amp;翻转 左右存放区 以&lt;当前展现的海报区&gt;切分为左右区域 作用是存放其他的海报 每个海报位置随机，角度随机 控制条区 控制&amp;展现对应的海报 翻面切换&lt;当前展现&gt;的海报它的正反面 VCD分解V(view视觉)：HTML+CSS基本的界面模板C(Controller控制)：javascript内容处理，事件处理D(Data)：data.js非必须，助于理解 view视觉 div.wrap:整个海报画廊的框架 div.photo：海报 div.photo.photo_center：中间的海报 div.side.side-font：海报前面 div.side.side-back：海报后面 p.desc：后面的描述性信息 p.img：海报内容图片 p.caption：海报上的字 div.nav：控制条区域 span.i：控制按钮 Data数据 图片(i name.jpg) data.js（var data = [{},…];）123caption:&quot;name&quot;desc:&quot;description&quot;img:&quot;url&quot; 处理代码：1234567891011121314151617181920212223242526272829data.jsvar data = [];var dataStr = &apos;1、霍比特人3&lt;br&gt;\\&lt;br&gt;\\导演：彼得杰克逊&lt;br&gt;\\编剧：……&lt;br&gt;\\主演：……&lt;br&gt;\\类型：……&lt;br&gt;\\制片国家/地区：……&lt;br&gt;\\语言：……&lt;br&gt;\\上映日期：……&lt;br&gt;\\片长：……&lt;br&gt;\\&lt;br&gt;\\&lt;br&gt;\\2、……...//定义的字符串&apos;var d = dataStr.split(&apos;&lt;br&gt;&lt;br&gt;&lt;br&gt;&apos;)//将每张照片的信息存到数组中去for(var i = 0;i&lt;d.length;i++)&#123; var c = d[i].split(&apos;&lt;br&gt;&lt;br&gt;&apos;);//将标题和内容分开 data.push(&#123; img:c[0].replace(&apos;、&apos;,&apos; &apos;)+&apos;.jpg&apos;,//将标题的顿号换成空格加上&quot;.jpg&quot; caption:c[0].split(&apos;、&apos;)[1],//将标题设置为顿号后面的 desc:c[1]//描述 &#125;); console.log(c[0].replace(&apos;、&apos;,&apos; &apos;)+&apos;.jpg&apos;);//打印出图片名&#125; Controller控制 输出所有海报内容（视图模板+数据） 位置分配控制（中央位置、两边位置） 控制条输出&amp;控制（切换、翻面） 代码编写垂直居中123456/*wrap垂直居中*/width:100%;height:600px;position:absolute;top:50%;margin-top:-300px; 基本界面编写 字体 1-webkit-font-smoothing:antialiased;//字体平滑 盒模型（图片超出边框），可以修改图片的大小，但是如果修改了就会造成最后图片大小不会岁边框大小变化，所以设置盒模型 1box-sizing:border-box;//可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。 水平垂直居中： 1234567width:260px;height:320px;left:50%;top:50%;margin-left:-160px;margin-top:-130px;z-index:999; photo负责平移和旋转，.photo-wrap负责3D翻转 123456789/*wrap*/-webkit-perspective:800;//支持3D效果/*photo-wrap*/-webkit-transform-style:preserve-3d;//支持子元素的3D效果/*side-front和side-back*/-webkit-transform:rotateY(0deg/180deg-webkit-transform:translate(0px,0px) rotateY(0deg);//定义位移以及沿着Y轴旋转/*.side*/-webkit-backface-visibility:hidden;//定义元素不面向屏幕时不可见 过渡动画 transition:property duration timing-function delay; property:规定设置过渡效果的CSS属性的名称； duration：规定完成过渡效果需要多少秒或者毫秒； timing-function：规定速度效果的速度曲线，默认ease； delay：定义过渡效果延迟多久开始，默认0。 脚本操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//1、翻面控制function turn(elem)&#123; var cls = elem.className; if(/photo_front/.test(cls))&#123; cls = cls.replace(&apos;/photo_front/&apos;,&apos;front_back&apos;); &#125;else&#123; cls = cls.replace(&apos;/photo_back/&apos;,&apos;front_front&apos;); &#125; return elem.className = cls;&#125;//2.源码输出data.js模板字符串：利用已经编写好的视图，隐藏起来，然后使用innerHTML获得其源码字符串。关键字替换：遍历数据，且从源码字符串中的数据部分替换为真实的数据。拼接好最终内容的HTML字符串回写（回写到.wrap中）//通用函数function g(selector)&#123; var method = selector.substr(0,1) == &apos;.&apos;?&apos;getElementsByClassName&apos;:&apos;getElementById&apos;; return document[method](selector.substr(1));&#125;//输出所有的海报var data = data;function addPhotos()&#123; var template = g(&apos;#wrap&apos;).innerHTML; var html = []; for( s in data)&#123; var _html = template .replace(&apos;&#123;&#123;index&#125;&#125;&apos;,s) .replace(&apos;&#123;&#123;img&#125;&#125;&apos;,data[s].img) .replace(&apos;&#123;&#123;caption&#125;&#125;&apos;,data[s].caption) .replace(&apos;&#123;&#123;desc&#125;&#125;&apos;,data[s].desc) html.push(_html); &#125; g(&apos;#wrap&apos;).innerHTML = html.join(); rsort(random([0,data.length]));&#125;//随机生成一个值,支持取值范围。random([min,max])function random(range)&#123; var max = Math.max(range[0],range[1]); var max = Math.min(range[0],range[1]); var diff = max - min;// var number =Math.ceil( Math.random()*diff+min); return number;&#125;//6.计算左右分区的范围function range()&#123; var range = &#123;left:&#123;x:[],y:[]&#125;,right:&#123;x:[],y:[]&#125;&#125;; return range;&#125;//排序海报function rsort(n)&#123; var _photo = g(&apos;.photo&apos;);//一个变量不常用就在前面加上下划线的形式命名 var photos = []; for(s = 0;s &lt;_photo.length;s++)&#123; _photo[s].className = _photo[s].className.replace(/\\s*photo_center\\s*/,&apos; &apos;); photos.push(_photo[s]); &#125; var photo_center = g(&apos;#photo_&apos;+n); photo_center.className += &apos;photo_center&apos;; photo_center = photos.splice(n,1)[0]; //把海报分为左、右两个分区 var photos_left = photos.splice(0,Math.ceil(photos.length/2)); var photos_rigth = photos;\\ for(s in photo_left)&#123; &#125; for(s in photo_right)&#123; &#125;&#125; 待续…… 参考资料慕课视频 参考案例","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/Fawziasfq/tags/javascript/"},{"name":"CSS3","slug":"CSS3","permalink":"https://github.com/Fawziasfq/tags/CSS3/"},{"name":"HTML5","slug":"HTML5","permalink":"https://github.com/Fawziasfq/tags/HTML5/"}]},{"title":"解决跨域问题的N种方法","date":"2017-03-11T12:33:00.000Z","path":"2017/03/11/解决跨域问题的N种方法/","text":"1.什么是跨域 概念：只要协议、域名、端口有任何一个不同，都被当作是不同的域。 对于端口和协议的不同，只能通过后台来解决。 如何解决跨域问题？1.通过jsonp跨域 jsonp：是资料格式的一种“使用模式”，可以让网页从别的网域获取资料；也叫做填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON。是一种非正式协议，该协议的一个要点就是允许用户传递一个callback参数给服务器端，然后服务器端返回数据时会将这个callback参数座位函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里12345678910111213141516171819&lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement(&apos;script&apos;); oScript.type = &apos;text/javascript&apos;; oScript.src = sUrl; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript); &#125; createJs(&apos;jsonp.js&apos;); box(&#123; &apos;name&apos;: &apos;test&apos; &#125;); function box(json)&#123; alert(json.name); &#125;&lt;/script&gt; 2.CORS服务器端对于CORS的支持，主要是通过设置Access-Control-Allow-Origin来进行的，如果浏览器检测到相应的设置，就可以允许Ajax进行跨域。 JSONP和CORS对比 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求； 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSON有更好的错误处理； JSONP主要是被老的浏览器支持，他们往往不支持CORS，而绝大多数现代浏览器 都已经支持了CORS。 3.通过修改document.domain来跨子域浏览器同源策略： 不能通过ajax的方法去请求不同源中的文档； 浏览器中不同域的框架之间不能进行js的交互设计。 不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.example.com/a.html ， 在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：123456789&lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var iframe = document.getElementById(&apos;￼ifame&apos;); var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的 var doc = win.document;//这里获取不到iframe里的document对象 var name = win.name;//这里同样获取不到window对象的name属性 &#125;&lt;/script&gt;&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt; 这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。 1.在页面 http://www.example.com/a.html 中设置document.domain:1234567&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.domain = &apos;example.com&apos;;//设置成主域 function test()&#123; alert(document.getElementById(&apos;￼iframe&apos;).contentWindow);//contentWindow 可取得子窗口的 window 对象 &#125;&lt;/script&gt; 2.在页面 http://example.com/b.html 中也设置document.domain:123&lt;script type=&quot;text/javascript&quot;&gt; document.domain = &apos;example.com&apos;;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同&lt;/script&gt; 修改document.domain的方法只适用于不同子域的框架间的交互。 4.使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过所有页面中的。 5.HTML5的window.postMessage方法跨域window。postMessage(message,targetOrigin)方法是html5新引进的特性，可以使用它来向其他的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera灯浏览器都已经支持window.postMessage方法。 参考： (Ajax)浅谈JSONP的原理与实现 详解js跨域问题","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/Fawziasfq/tags/javascript/"}]},{"title":"深信服一面","date":"2017-03-10T13:54:33.000Z","path":"2017/03/10/深信服一面/","text":"算法： 1.如何将字符串中的单词反转，比如“we are people.” -&gt;”.people are we”。 1.让div隐藏的方法有哪些？ 2.如何让一个元素的点击面扩大？ 3.说一下伪数组 4.子元素如何撑开父元素 js： 1.如何判断一个字符串的类型 2.如何判断一个对象是不是对象 3.如何判断一个数组是不是数组","tags":[]},{"title":"Webpack学习笔记","date":"2017-03-07T13:27:33.000Z","path":"2017/03/07/Webpack学习笔记/","text":"Webpack是如今最热门的前端资源模块化管理和打包工具。 将松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。 将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。 通过loader的转换，任何形式的资源都可以视为模块。 什么是WebpackWebpack是一个将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源的模块打包器。 适用于维护一个大规模的代码库中各种资源的分割和存放，依赖关系和无缝整合到一起生成适合浏览器端请求加载的静态资源。可以完成： 将依赖树拆分成按需加载的块； 初始化加载的耗时时间少； 各种静态资源可以视作模块 将第三方静态资源整合成模块的能力； 可以自定义打包逻辑的能力； 适合大项目，无论是单页的还是多页的Web应用。 Webpack的特点主要是和其它模块化工具的区别： 代码拆分：Webpack有两种组织模块依赖的方式，同步和异步。优化依赖树后，每一个异步区块都作为一个文件被打包。 虽然Webpack只能处理原生的javascript模块，但是loader转换器可以将各种类型的资源转换成javascript模块。 智能解析：Webpack有一个智能解析库，几乎可以处理任何第三方库。 插件系统：Webpack有一个功能丰富的插件系统，大多数内容功能都是基于这个插件系统运行的。 快速运行：Webpack使用异步I/O和多级缓存提高运行效率。","tags":[{"name":"工具学习","slug":"工具学习","permalink":"https://github.com/Fawziasfq/tags/工具学习/"}]},{"title":"重绘和重排的性能优化","date":"2017-03-06T14:17:44.000Z","path":"2017/03/06/重绘和重排的性能优化/","text":"重排：当DOM变化影响了元素的几何属性，页面中的其他元素的集合属性也可能会受影响，浏览器就需要重新计算元素的几何属性，这样渲染树就发生了变化，也就是重新构造了渲染树，这个过程叫做重排。 重绘：如果DOM变化仅仅只是影响了背景色等等非几何属性，就发生的是重绘而不是重排，因为布局没有发生变化。 触发重排页面布局和几何属性的变化： 页面初始渲染； 添加/删除可见的DOM元素； 改变元素的位置； 改变元素的尺寸； 改变元素内容； 改变窗口尺寸； 不同情况下发生的重排的范围及程度不同，某些情况下会重排整个页面，比如滑动滚动条。 浏览器的优化：渲染队列现代浏览器都有渲染队列的机制，当改变元素的一个样式会导致浏览器发生重排或重绘时，它会进入一个渲染队列，然后如果后面还有样式修改，同样入队，知道没有样式修改，按照渲染队列批量执行来重排过程，一并修改样式，这样就把本该几次的重排优化成了一次。 但是offset-，会强制刷新队列要求样式修改任务立即执行。会刷新渲染队列 offset- client- scroll- getComputedStyle()（IE中的currentStyle） 重绘和重排的性能优化分离读写操作把读操作移到写操作后，TRBL这这些操作写到一起，offset的操作写到一起，这样就会几次重排合成一次重排。 样式集中改变 javascript中改变样式直接用cssText属性合并所有样式改变。这样就只会触发依次重排。但是cssText会覆盖已有的行间样式，所以要保留原有的行间样式就使用 “+=” 修改class类名来进行样式修改。 缓存布局信息分离读写操作 元素批量修改","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/Fawziasfq/tags/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"https://github.com/Fawziasfq/tags/性能优化/"}]},{"title":"字符串和正则表达式","date":"2017-03-02T13:58:23.000Z","path":"2017/03/02/字符串和正则表达式/","text":"几乎所有的javascript程序都与字符串操作密切相关，一个典型的应用程序通常需要处理大量类似合并、分割、重新排序、搜索、遍历等字符串操作。 字符串连接字符串链接会导致令人惊讶的性能问题。构建字符串的常用方法是：通过循环，向字符串末尾不断地添加内容。有很多方法可以优化这类任何，多种方法合并字符串： the + operator the += operator array.join() string.concat() 这类方法运行速度都很快，随着需要合并的字符串的长度和数量的增加，一些方法的优势开始展现。 加和加等操作符除了IE7及之前的版本的所有浏览器都对它们进行了良好的优化。 正则表达式####为什么使用正则表达式我们先来看看，我们干哈要学正则表达式这玩意儿： 复杂的字符串搜寻、替换工作，无法用简单的方式(类似借助标准库函数)达成。 能够帮助你进行各种字符串验证。 不止应用于编程语言中：JavaScript、JAVA、Perl、PHP、C#… 也应用于许多操作系统的主流指令中：Linux/Unix、Mac、Windows PowerScript在我们常用的开发工具中，如Fiddler Willow、WebStorm、Vim，正则表达式也能帮助我们方便的进行Find&amp;Replace的工作。由于正则表达式的流派很多，这篇文章主要是描述JavaScript中的正则表达式。 未完待续……","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/Fawziasfq/tags/javascript/"}]},{"title":"Hello World","date":"2017-03-01T07:32:19.559Z","path":"2017/03/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]